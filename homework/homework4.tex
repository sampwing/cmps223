\documentclass[11pt]{amsart}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{enumerate}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\title{CMPS223: Homework \#3}
\author{Sam Wing}
%\date{}                                           % Activate to display a given date or no date

\begin{document}
\maketitle
\section{MicroIL}

Below are the given examples walking them through using MicroIL:

\begin{enumerate}[a)]
	\item push0 $\cdot$ inc $\cdot$ halt
	\begin{enumerate}[1)]
		\item P $\vdash$ $< 1, f, s >$
		\item $\rightarrow$ $< 2, f, 0 \cdot s >$ (push0)
		\item $\rightarrow$ $< 3, f, 1 \cdot s >$ (inc)
		\item (halt)		
	\end{enumerate}
	
	\item inc $\cdot$ inc $\cdot$ halt
	\begin{enumerate}[1)]
		\item P $\vdash$ $< pc, f, s >$
		\item $\rightarrow$ $<pc + 1, f, (n + 1) \cdot s >$ (inc -error, cannot increment epsilon)
	\end{enumerate}
\end{enumerate}

Although the first program (a) completes successful, the second (b) does not.  This is because before program$_b$ has any value on the stack, it tries to increment the value.  We cannot allow the program to increment $\epsilon$ because there is nothing on the stack yet, so I believe that this program will fail.  

Below is the type during each function call throughout program$_a$:

\begin{enumerate}[a)]
	\item push0 $\cdot$ inc $\cdot$ halt
	\begin{enumerate}[1)]
		\item $P_1$ = init, $F_1$ = Top, $S_1$ = $\epsilon$	
		\item $P_2$ = push0, $F_2$ = Top, $S_2$ = Int $\cdot $  $\epsilon$
		\item $P_3$ = init, $F_3$ = Top, $S_3$ = Int $\cdot$ $\epsilon$
		\item F, S, 3 $\vdash$ P
	\end{enumerate}
\end{enumerate}

\section{Operator Equivalence}

\begin{verbatim}

function f():
    return random_int()
 
function g_x(a):
    return a & true

function g_y(a):
    return (a ? true : false) & true

\end{verbatim}

We are trying to show that the equivalence is not preserved through these two logically similar functions.  Say for example that we get a value b := f(), We will notice that for all positive and even numbers generated by this function that, $g_x$(b) $\rightarrow$ false, this is because true is internally stored as a 1 and the bitwise and operation between 1 and any odd number will be 0.  However $g_y$(b) $\rightarrow$ true.  This shows that when b is positive and even the equivalence between $g_x$ and $g_y$ is not held.  However when the value of b is odd the relation between the two functions will hold, due to the bitwise and operation, true(1) \& b $\rightarrow$ 1.

\end{document}  